#!/usr/bin/ruby

require 'optparse'
require 'shellwords'
require 'tmpdir'
require 'fileutils'
require 'time'
require 'chupa'
require 'groonga'

class ChupaDatabase
  def initialize
    @wget = nil
    @database = nil
    @log_file = nil
    @url_prefix = nil
    @category_file = nil
    @category_table = {}
    @auto_delete = false
    @ignore_erros = false
    @debug = false
  end

  def set_options(opts)
    banner = opts.banner
    opts.banner = <<EOS
#{banner} --from-log=LOG db-path base-directory
#{banner} [--url-prefix=PREFIX] db-path files...

EOS

    opts.define("-w", "--wget[=WGET-PATH]") do |v|
      @wget = v ? Shellwords.split(v) : %w[wget]
    end
    opts.define("-f", "--from-log=FILE") do |v|
      @log_file = v
    end
    opts.define("-p", "--url-prefix=URL_PREFIX") do |v|
      @url_prefix = v
    end
    opts.define("-c", "--category-file=CATEGORY_FILE") do |v|
      @category_file = v
    end
    opts.define("-d", "--[no-]auto-delete") do |v|
      @auto_delete = v
    end
    opts.define("-i", "--[no-]ignore-errors") do |v|
      @ignore_erros = v
    end
    opts.define("--[no-]debug") do |v|
      @debug = v
    end
    opts
  end

  def prepare(args)
    db = args.shift
    return if db.nil?
    if @log_file or @wget
      if @url_prefix
        raise OptionParser::InvalidOption, "--url-prefix can't be used in wget mode"
      end
    end
    if @wget
      if args.empty? and not @category_file
        return
      end
    elsif @log_file
      base = args.shift
      return if base.nil?
      return unless args.empty?
      Dir.open(base) {}
      process = proc {
        if @log_file == '-'
          process_from_log(db, base, STDIN)
        else
          File.open(@log_file) {|input|
            process_from_log(db, base, input)
          }
        end
      }
    else
      return if args.empty?
      process = proc {
        args.each {|file| process_file(db, file)}
      }
    end

    if @category_file
      File.foreach(@category_file) do |line|
        cat, title = line.strip.split(/\t+/)
        @category_table[cat] = title
      end
    end

    if @wget
      if args.empty? and (args = @category_table.keys).empty?
        raise OptionParser::MissingArgument, "no URL"
        return
      end
      process = proc {
        @auto_delete = true
        base = Dir.mktmpdir("ranguba")
        wget = [{"LC_ALL"=>"C"}, *@wget, "-S", *args, chdir: base, err: [:child, :out]]
        begin
          IO.popen(wget, "r", encoding: "us-ascii") {|input|
            process_from_log(db, base, input)
          }
        ensure
          FileUtils.rm_f(base)
        end
      }
    end

    process
  end

  def process_file(db, path)
    open(db) do |grn|
      url = @url_prefix ? @url_prefix + path : path
      add_entry(grn, url, path)
      postprocess_file(path)
    end
  end

  def process_from_log(db, base, input)
    result = true
    open(db) do |grn|
      url = response = file = path = nil
      input.each("") do |log|
        case log
        when /^--([-\d]+.*?)\s*--\s+(.+)/
          update = $1
          url = $2
          puts "URL: #{url}"
          if response = log[/^(?:  .*\n)+/]
            response = Hash[response.lines.grep(/^\s*([-A-Za-z0-9]+):\s*(.*)$/) {[$1.downcase, $2]}]
          end
          file = log[/^Saving to: \`(.+)\'$/, 1]
          next unless file      # failed to start download
          path = File.join(base, file)
          response ||= {}
          response["x-update-time"] = Time.parse(update)
        when /saved/
          next unless url and path and File.file?(path)
          add_entry(grn, url, path, response)
          postprocess_file(path)
          path = nil
        end
      end
    end
    result
  end

  def add_entry(grn, url, path, response = {})
    begin
      metadata, body = decompose_file(path, response)
      return false if metadata.nil?
      attributes = make_attributes(url, response, metadata, path)
      attributes.update(body: body)
      grn.entries.add(url, attributes)
    rescue => e
      unless @ignore_erros
        STDERR.puts "#{e.class}: #{e.message}"
        STDERR.puts e.backtrace.map{|s|"\t#{s}"}
        return false
      end
    end
    true
  end

  def postprocess_file(path)
    if @auto_delete
      FileUtils.rm_f(path)
    end
  end

  def decompose_file(path, response = {})
    Chupa.decompose(path, response)
  end

  def open(path, encoding = Encoding::UTF_8)
    if File.exist?(path)
      @database = Groonga::Database.open(path)
      populate_schema
    else
      FileUtils.mkdir_p(File.dirname(path))
      reset_context(encoding)
      populate(path)
    end
    if block_given?
      begin
        yield(self)
      ensure
        close unless closed?
      end
    end
  end

  def purge
    path = @database.path
    encoding = @database.encoding
    @database.remove
    FileUtils.rm_f([path, *Dir[path+".*"]])
    reset_context(encoding)
    populate(path)
  end

  def close
    puts "Closing database #{@database.path}" if @debug
    @database.close
    @database = nil
  end

  def closed?
    @database.nil? or @database.closed?
  end

  def types
    @types ||= Groonga["Types"]
  end

  def charsets
    @charsets ||= Groonga["Charsets"]
  end

  def categories
    @categories ||= Groonga["Categories"]
  end

  def entries
    @entries ||= Groonga["Entries"]
  end

  def make_attributes(url, response, meta, path)
    if mtime = response["last-modified"] || meta["last-modified"]
      begin
        mtime = Time.parse(mtime)
      rescue
        mtime = nil
      end
    end
    mtime ||= File.mtime(path) if path
    {
      title: meta["title"],
      type: response["content-type"] || meta["mime-type"] || "",
      charset: response["charset"] || meta["charset"] || "",
      category: get_category(url) || "",
      author: get_author(meta) || "",
      mtime: mtime,
      update: response["x-update-time"],
    }
  end

  private

  def get_category(url)
    cat, title = @category_table.select {|c, t| url.start_with?(c)}.max_by {|c, t| c.length}
    title
  end

  def get_author(meta)
    meta["author"]
  end

  def reset_context(encoding)
    Groonga::Context.default_options = {:encoding => encoding.to_s.downcase}
    Groonga::Context.default = nil
  end

  def populate(path)
    @database = Groonga::Database.create(:path => path)
    populate_schema
  end

  def populate_schema
    Groonga::Schema.define do |schema|
      schema.create_table("Types", :type => :hash,
                          :key_type => "ShortText") do |table|
      end

      schema.create_table("Charsets", :type => :hash,
                          :key_type => "ShortText") do |table|
      end

      schema.create_table("Categories", :type => :hash,
                          :key_type => "ShortText") do |table|
        table.text("title")
      end

      schema.create_table("Entries", :type => :hash,
                          :key_type => "ShortText") do |table|
        table.text("title")
        table.reference("type", "Types")
        table.reference("charset", "Charsets")
        table.reference("category", "Categories")
        table.short_text("author")
        table.time("mtime")
        table.time("update")
        table.text("body")
      end

      schema.create_table("Bigram",
                          :type => :patricia_trie,
                          :key_type => "ShortText",
                          :default_tokenizer => "TokenBigram",
                          :key_normalize => true) do |table|
        table.index("Entries.body", :with_position => true)
        table.index("Entries.title", :with_position => true)
      end

      schema.change_table("Types") do |table|
        table.index("Entries.type")
      end

      schema.change_table("Charsets") do |table|
        table.index("Entries.charset")
      end

      schema.change_table("Categories") do |table|
        table.index("Entries.category")
      end
    end
  end
end

class ChupaDatabase::TestOnly < ChupaDatabase
  SUFFIX_TYPE = {'.html' => 'text/html', '.txt' => 'text/plain'}

  def decompose_file(path, response = {})
    case response["content-type"] ||= SUFFIX_TYPE[File.extname(path)]
    when "text/html"
      return decompose_html_file(path, response)
    when "text/plain"
      return decompose_text_file(path, response)
    else
      super
    end
  end

  def decompose_text_file(path, response)
    File.open(path) {|f|
      meta = response.update("last-modified" => f.mtime,
                             "mime-type" => response["content-type"])
      return meta, f.read
    }
  end

  def decompose_html_file(path, response)
    require 'nokogiri'
    doc = File.open(path, 'rb') {|file| Nokogiri::HTML.parse(file)}
    metadata = {}
    metadata["title"] = (doc % "head/title").text
    if encoding = doc.encoding
      metadata["charset"] = encoding.downcase
    end
    body = (doc % "body").text.gsub(/^\s+|\s+$/, '')
    return metadata, body
  end
end

chupadb = ChupaDatabase::TestOnly.new
opts = nil
runner = ARGV.options {|o|
  opts = o
  opts.separator("Options:")
  chupadb.set_options(opts)
  chupadb.prepare(opts.parse!(ARGV))
}
abort opts.to_s if runner.nil?
exit runner.call
