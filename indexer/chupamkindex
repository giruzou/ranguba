#!/usr/bin/ruby

require 'optparse'
require 'fileutils'
require 'chupa'
require 'groonga'

class ChupaDatabase
  def initialize
    @database = nil
    @log_file = nil
    @url_prefix = nil
    @category_file = nil
    @category_table = {}
    @ignore_erros = false
    @debug = false
  end

  def set_options(opts)
    banner = opts.banner
    opts.banner = <<EOS
#{banner} --from-log=LOG db-path base-directory
#{banner} [--url-prefix=PREFIX] db-path files...

EOS

    opts.define("-f", "--from-log=FILE") do |v|
      @log_file = v
    end
    opts.define("-p", "--url-prefix=URL_PREFIX") do |v|
      @url_prefix = v
    end
    opts.define("-c", "--category-file=CATEGORY_FILE") do |v|
      @category_file = v
    end
    opts.define("-i", "--[no-]ignore-errors") do |v|
      @ignore_erros = v
    end
    opts.define("--[no-]debug") do |v|
      @debug = v
    end
    opts
  end

  def prepare(args)
    db = args.shift or return
    if @log_file
      if @url_prefix
        raise OptionParser::InvalidOption, "--url-prefix and --from-log are exclusive"
      end
      base = args.shift or return
      return unless args.empty?
      Dir.open(base) {}
      process = proc {
        if @log_file == '-'
          process_from_log(db, base, STDIN)
        else
          File.open(@log_file) {|input|
            process_from_log(db, base, input)
          }
        end
      }
    else
      return if args.empty?
      process = proc {
        args.each {|file| process_file(db, file)}
      }
    end
    
    if @category_file
      File.foreach(@category_file) do |line|
        cat, title = line.strip.split(/\t+/)
        @category_table[cat] = title
      end
    end

    process
  end

  def process_file(db, path)
    open(db) do |grn|
      url = @prefix ? @prefix + path : path
      add_entry(grn, url, path)
    end
  end

  def process_from_log(db, base, input)
    result = true
    open(db) do |grn|
      url = response = file = path = nil
      input.each("") do |log|
        next unless (found = log[/^--[-\d]+.*?--\s+(.+)/, 1])..(saved = log[/saved/])
        if found
          url = found
          puts "URL: #{url}"
          if response = log[/^(?:  .*\n)+/]
            response = Hash[response.lines.grep(/^\s*([-A-Za-z0-9]+):\s*(.*)$/) {[$1.downcase, $2]}]
          end
          file = log[/^Saving to: \`(.+)\'$/, 1]
          path = File.join(base, file)
          File.file?(path) or next
        elsif saved
          add_entry(grn, url, path, response)
        end
      end
    end
    result
  end

  def add_entry(grn, url, path, response = {})
    begin
      metadata, body = (decompose_file(path, response) or return false)
      attributes = make_attributes(url, response, metadata, path)
      attributes.update(body: body)
      grn.entries.add(url, attributes)
    rescue => e
      unless @ignore_erros
        STDERR.puts "#{e.class}: #{e.message}"
        STDERR.puts e.backtrace.map{|s|"\t#{s}"}
        return false
      end
    end
    true
  end

  def decompose_file(path, response = {})
    Chupa.decompose(path, response)
  end

  def open(path, encoding = Encoding::UTF_8)
    if File.exist?(path)
      @database = Groonga::Database.open(path)
      populate_schema
    else
      FileUtils.mkdir_p(File.dirname(path))
      reset_context(encoding)
      populate(path)
    end
    if block_given?
      begin
        yield(self)
      ensure
        close unless closed?
      end
    end
  end

  def purge
    path = @database.path
    encoding = @database.encoding
    @database.remove
    FileUtils.rm_f([path, *Dir[path+".*"]])
    reset_context(encoding)
    populate(path)
  end

  def close
    puts "Closing database #{@database.path}" if @debug
    @database.close
    @database = nil
  end

  def closed?
    @database.nil? or @database.closed?
  end

  def types
    @types ||= Groonga["Types"]
  end

  def charsets
    @charsets ||= Groonga["Charsets"]
  end

  def categories
    @categories ||= Groonga["Categories"]
  end

  def entries
    @entries ||= Groonga["Entries"]
  end

  def make_attributes(url, response, meta, path)
    if mtime = response["last-modified"]||meta["last-modified"]
      require 'date'
      mtime = (DateTime.parse(mtime) rescue nil)
    end
    mtime ||= File.mtime(path) if path
    {
      title: meta["title"],
      type: response["content-type"]||meta["mime-type"]||"",
      charset: response["charset"]||meta["charset"]||"",
      category: get_category(url)||"",
      author: get_author(meta)||"",
      last: mtime,
    }
  end

  private

  def get_category(url)
    @category_table.select {|cat, title| url.start_with?(cat)}.max_by {|cat, title| cat.length}[1]
  end

  def get_author(meta)
    meta["author"]
  end

  def reset_context(encoding)
    Groonga::Context.default_options = {:encoding => encoding.to_s.downcase}
    Groonga::Context.default = nil
  end

  def populate(path)
    @database = Groonga::Database.create(:path => path)
    populate_schema
  end

  def populate_schema
    Groonga::Schema.define do |schema|
      schema.create_table("Types", :type => :hash,
                          :key_type => "ShortText") do |table|
      end

      schema.create_table("Charsets", :type => :hash,
                          :key_type => "ShortText") do |table|
      end

      schema.create_table("Categories", :type => :hash,
                          :key_type => "ShortText") do |table|
        table.text("title")
      end

      schema.create_table("Entries", :type => :hash,
                          :key_type => "ShortText") do |table|
        table.text("title")
        table.reference("type", "Types")
        table.reference("charset", "Charsets")
        table.reference("category", "Categories")
        table.short_text("author")
        table.time("last")
        table.text("body")
      end

      schema.create_table("Bigram",
                          :type => :patricia_trie,
                          :key_type => "ShortText",
                          :default_tokenizer => "TokenBigram",
                          :key_normalize => true) do |table|
        table.index("Entries.body", :with_position => true)
        table.index("Entries.title", :with_position => true)
      end

      schema.change_table("Types") do |table|
        table.index("Entries.type")
      end

      schema.change_table("Charsets") do |table|
        table.index("Entries.charset")
      end

      schema.change_table("Categories") do |table|
        table.index("Entries.category")
      end
    end
  end
end

class ChupaDatabase::TestOnly < ChupaDatabase
  def decompose_file(path, response = {})
    case response["content-type"]
    when "text/html"
      decompose_html_file(path)
    when "text/plain"
      File.open(path) {|f|
        meta = response.update("last-modified" => f.mtime,
                               "mime-type" => response["content-type"])
        return meta, f.read
      }
    else
      super
    end
  end

  def decompose_html_file(path)
    require 'nokogiri'
    doc = File.open(path, 'rb') {|file| Nokogiri::HTML.parse(file)}
    metadata = {}
    metadata["title"] = (doc % "head/title").text
    if encoding = doc.encoding
      metadata["charset"] = encoding.downcase
    end
    body = (doc % "body").text.gsub(/^\s+|\s+$/, '')
    return metadata, body
  end
end

chupadb = ChupaDatabase::TestOnly.new
opts = nil
runner = ARGV.options do |o|
  opts = o
  opts.separator("Options:")
  chupadb.set_options(opts)
  chupadb.prepare(opts.parse!(ARGV))
end or abort opts.to_s
exit runner.call
