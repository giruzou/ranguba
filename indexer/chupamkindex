#!/usr/bin/ruby

require 'optparse'
require 'fileutils'

class ChupaDatabase
  def initialize
    @database = nil
  end

  def set_options(opts)
    opts.banner << " db-path base-directory [log...]"
    opts.define("-i", "--[no-]ignore-errors") do |v|
      @ignore_erros = v
    end
    opts.define("--[no-]debug") do |v|
      @debug = v
    end
    opts
  end

  def prepare(args)
    db = args.shift or return
    base = args.shift or return
    Dir.open(base) {}
    input = ARGF.class.new(*args)
    return db, base, input
  end

  def process(db, base, input = STDIN)
    require 'chupa'
    require 'groonga'
    result = true
    open(db) do |grn|
      url = response = file = path = nil
      input.each("") do |log|
        case log
        when /^--[-\d]+.*?--\s+(.+)/
          url = $1
          puts "URL: #{url}"
          if response = log[/^(?:  .*\n)+/]
            response = Hash[response.lines.grep(/^\s*([-A-z0-9]+):\s*(.*)$/) {[$1.downcase, $2]}]
          end
          file = log[/^Saving to: \`(.+)\'$/, 1]
          path = File.join(base, file)
        when /saved/
          path or next
          File.file?(path) or next
          begin
            info = Chupa.decompose(path, response)
            attributes = make_attributes(url, response, info.metadata)
            attributes.update(body: chupa.body)
            grn.entries.add(url, attributes)
          rescue => e
            unless @ignore_erros
              STDERR.puts "#{e.class}: #{e.message}"
              STDERR.puts e.backtrace.map{|s|"\t#{s}"}
              result = false
            end
          ensure
            path = nil
          end
        end
      end
    end
    result
  end

  def open(path, encoding = Encoding::UTF_8)
    if File.exist?(path)
      @database = Groonga::Database.open(path)
      populate_schema
    else
      FileUtils.mkdir_p(File.dirname(path))
      reset_context(encoding)
      populate(path)
    end
    if block_given?
      begin
        yield(self)
      ensure
        close unless closed?
      end
    end
  end

  def purge
    path = @database.path
    encoding = @database.encoding
    @database.remove
    FileUtils.rm_f([path, *Dir[path+".*"]])
    reset_context(encoding)
    populate(path)
  end

  def close
    @database.close
    @database = nil
  end

  def closed?
    @database.nil? or @database.closed?
  end

  def types
    @types ||= Groonga["Types"]
  end

  def charsets
    @charsets ||= Groonga["Charsets"]
  end

  def categories
    @categories ||= Groonga["Categories"]
  end

  def entries
    @entries ||= Groonga["Entries"]
  end

  def make_attributes(url, response, meta)
    {
      title: meta["title"],
      type: response["content-type"]||meta["mime-type"]||"",
      charset: response["charset"]||meta["charset"]||"",
      category: get_category(url),
      author: get_author["meta"],
    }
  end

  private

  def reset_context(encoding)
    Groonga::Context.default_options = {:encoding => encoding.to_s.downcase}
    Groonga::Context.default = nil
  end

  def populate(path)
    @database = Groonga::Database.create(:path => path)
    populate_schema
  end

  def populate_schema
    Groonga::Schema.define do |schema|
      schema.create_table("Types", :type => :hash,
                          :key_type => "ShortText") do |table|
      end

      schema.create_table("Charsets", :type => :hash,
                          :key_type => "ShortText") do |table|
      end

      schema.create_table("Categories", :type => :hash,
                          :key_type => "ShortText") do |table|
        table.text("title")
      end

      schema.create_table("Entries", :type => :hash,
                          :key_type => "ShortText") do |table|
        table.text("title")
        table.reference("type", "Types")
        table.reference("charset", "Charsets")
        table.reference("category", "Categories")
        table.short_text("author")
        table.time("last")
        table.text("body")
      end

      schema.create_table("Bigram",
                          :type => :patricia_trie,
                          :key_type => "ShortText",
                          :default_tokenizer => "TokenBigram",
                          :key_normalize => true) do |table|
        table.index("Entries.body", :with_position => true)
        table.index("Entries.title", :with_position => true)
      end

      schema.change_table("Types") do |table|
        table.index("Entries.type")
      end

      schema.change_table("Charsets") do |table|
        table.index("Entries.charset")
      end

      schema.change_table("Categories") do |table|
        table.index("Entries.category")
      end
    end
  end
end

chupadb = ChupaDatabase.new 
opts = OptionParser.new
opts.separator("Options:")
chupadb.set_options(opts)
exit chupadb.process(*((chupadb.prepare(opts.parse!(ARGV)) rescue abort $!.message) or abort opts.to_s))
